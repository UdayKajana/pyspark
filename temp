# First, update the ConvertToSpannerMutation class to include new timestamp fields
class ConvertToSpannerMutation(NamedTuple):
    telephone_number: Optional[str]
    trouble_report_number: Optional[str]
    address_id: Optional[str]
    chronic_flag: Optional[str]
    chronic_total: Optional[str]
    circuit_id: Optional[str]
    circuit_type: Optional[str]
    reported_ts: Optional[str]
    data_circuit_id: Optional[str]
    video_circuit_id: Optional[str]
    window_timestamp: Optional[str]  # New field
    insertion_timestamp: Optional[str]  # New field
beam.coders.registry.register_coder(ConvertToSpannerMutation, beam.coders.RowCoder)

class PrepareSpannerData(beam.DoFn):
    def process(self, element, window=beam.DoFn.WindowParam, timestamp=beam.DoFn.TimestampParam) -> Iterator[ConvertToSpannerMutation]:
        try:
            # Get window end time
            window_end = window.end.to_utc_datetime().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            
            # Get current time for insertion
            current_time = datetime.utcnow().strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            
            yield self.transform_to_mutation(element, window_end, current_time)
        except Exception as e:
            logging.error(f"Error processing element: {element}")
            logging.error(f"Error details: {str(e)}")
            return

    def format_date(self, value):
        if value is None:
            return None
        try:
            if isinstance(value, str):
                dt = datetime.strptime(value.split('.')[0], '%Y-%m-%d %H:%M:%S')
                return dt.strftime('%Y-%m-%dT%H:%M:%S.%fZ')
            return value
        except Exception as e:
            logging.error(f"Date formatting error: {str(e)}")
            return None
    
    def safe_str(self, value):
        if value is None:
            return None
        try:
            return str(value)
        except Exception:
            return None

    def transform_to_mutation(self, element: dict, window_end: str, current_time: str):
        if not isinstance(element, dict):
            logging.error(f"Expected dictionary, got {type(element)}")
            return None
            
        if 'rawdata' in element:
            try:
                if isinstance(element['rawdata'], str):
                    element = json.loads(element['rawdata'])
                elif isinstance(element['rawdata'], dict):
                    element = element['rawdata']
            except json.JSONDecodeError as e:
                logging.error(f"Error decoding rawdata: {str(e)}")
                return None
            
        return ConvertToSpannerMutation(
            telephone_number=element.get('telephone_number'),
            trouble_report_number=element.get('trouble_report_num'),
            address_id=element.get('address_id'),
            chronic_flag=element.get('chronic_flag'),
            chronic_total=element.get('chronic_total'),
            circuit_id=element.get('line_id_trimmed'),
            circuit_type=element.get('port_associated_service'),
            reported_ts=self.format_date(element.get('date_opened')),
            data_circuit_id=element.get('data_circuit_id'),
            video_circuit_id=self.safe_str(element.get('video_circuit_id')),
            window_timestamp=window_end,  # New field
            insertion_timestamp=current_time  # New field
        )




CREATE TABLE vrepair_tkt_lkp (
    telephone_number STRING(20),
    trouble_report_number STRING(50),
    address_id STRING(50),
    chronic_flag STRING(5),
    chronic_total STRING(10),
    circuit_id STRING(50),
    circuit_type STRING(50),
    reported_ts TIMESTAMP,
    data_circuit_id STRING(50),
    video_circuit_id STRING(50),
    window_timestamp TIMESTAMP,    -- New column for window end time
    insertion_timestamp TIMESTAMP, -- New column for record insertion time
) PRIMARY KEY (trouble_report_number);
